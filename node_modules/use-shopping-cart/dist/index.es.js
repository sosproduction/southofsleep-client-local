import react, { createContext, useReducer, useEffect, useMemo, useContext } from 'react';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var common = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



function fromStorage(value) {
  return value !== null ? JSON.parse(value) : null;
}

function readItem(storage, key) {
  try {
    var storedValue = storage.getItem(key);
    return fromStorage(storedValue);
  } catch (e) {
    return null;
  }
}

function toStorage(value) {
  return JSON.stringify(value);
}

function writeItem(storage, key, value) {
  try {
    if (value !== null) {
      storage.setItem(key, toStorage(value));
    } else {
      storage.removeItem(key);
    }

    return Promise.resolve();
  } catch (error) {
    return Promise.reject(error);
  }
}

function useInitialState(storage, key, defaultState) {
  var defaultStateRef = react.useRef(defaultState);
  return react.useMemo(function () {
    var _a;

    return (_a = readItem(storage, key)) !== null && _a !== void 0 ? _a : defaultStateRef.current;
  }, [key, storage]);
}

exports.useInitialState = useInitialState;

function useStorageWriter(storage, key, state) {
  var _a = react.useState(undefined),
      writeError = _a[0],
      setWriteError = _a[1];

  react.useEffect(function () {
    writeItem(storage, key, state).catch(function (error) {
      if (!error || !error.message || error.message !== (writeError === null || writeError === void 0 ? void 0 : writeError.message)) {
        setWriteError(error);
      }
    });

    if (writeError) {
      return function () {
        setWriteError(undefined);
      };
    }
  }, [state, key, writeError, storage]);
  return writeError;
}

exports.useStorageWriter = useStorageWriter;

function useStorageListener(storage, key, defaultState, onChange) {
  var defaultStateRef = react.useRef(defaultState);
  var onChangeRef = react.useRef(onChange);
  var firstRun = react.useRef(true);
  react.useEffect(function () {
    var _a;

    if (firstRun.current) {
      firstRun.current = false;
      return;
    }

    onChangeRef.current((_a = readItem(storage, key)) !== null && _a !== void 0 ? _a : defaultStateRef.current);
  }, [key, storage]);
  react.useEffect(function () {
    function onStorageChange(event) {
      var _a;

      if (event.key === key) {
        onChangeRef.current((_a = fromStorage(event.newValue)) !== null && _a !== void 0 ? _a : defaultStateRef.current);
      }
    }

    if (typeof window !== 'undefined') {
      window.addEventListener('storage', onStorageChange);
      return function () {
        window.removeEventListener('storage', onStorageChange);
      };
    }
  }, [key]);
}

exports.useStorageListener = useStorageListener;
});

unwrapExports(common);
var common_1 = common.useInitialState;
var common_2 = common.useStorageWriter;
var common_3 = common.useStorageListener;

var state = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});





function useStorageState(storage, key, defaultState) {
  if (defaultState === void 0) {
    defaultState = null;
  }

  var _a = react.useState(common.useInitialState(storage, key, defaultState)),
      state = _a[0],
      setState = _a[1];

  common.useStorageListener(storage, key, defaultState, setState);
  var writeError = common.useStorageWriter(storage, key, state);
  return [state, setState, writeError];
}

exports.default = useStorageState;
});

unwrapExports(state);

var reducer = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});





var FORCE_STATE_ACTION = '__FORCE_STATE_INTERNAL_API__';

function isForceStateAction(action) {
  return typeof action === 'object' && action !== null && 'type' in action && action.type === FORCE_STATE_ACTION;
}

function addForceStateActionToReducer(reducer) {
  return function (state, action) {
    if (isForceStateAction(action)) return action.payload;
    return reducer(state, action);
  };
}

function useStorageReducer(storage, key, reducer, defaultInitialArg, defaultInit) {
  if (defaultInit === void 0) {
    defaultInit = function (x) {
      return x;
    };
  }

  var defaultState = defaultInit(defaultInitialArg);

  var _a = react.useReducer(addForceStateActionToReducer(reducer), common.useInitialState(storage, key, defaultState)),
      state = _a[0],
      dispatch = _a[1];

  common.useStorageListener(storage, key, defaultState, function (newValue) {
    dispatch({
      type: FORCE_STATE_ACTION,
      payload: newValue
    });
  });
  var writeError = common.useStorageWriter(storage, key, state);
  return [state, dispatch, writeError];
}

exports.default = useStorageReducer;
});

unwrapExports(reducer);

var dist = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



exports.useStorageState = state.default;



exports.useStorageReducer = reducer.default;
});

unwrapExports(dist);
var dist_1 = dist.useStorageState;
var dist_2 = dist.useStorageReducer;

var isClient = typeof window === 'object';
var formatCurrencyString = (_ref) => {
  var {
    value,
    currency,
    language = isClient ? navigator.language : 'en-US'
  } = _ref;
  value = parseInt(value);
  var numberFormat = new Intl.NumberFormat(language, {
    style: 'currency',
    currency,
    currencyDisplay: 'symbol'
  });
  var parts = numberFormat.formatToParts(value);
  var zeroDecimalCurrency = true;

  for (var part of parts) {
    if (part.type === 'decimal') {
      zeroDecimalCurrency = false;
      break;
    }
  }

  value = zeroDecimalCurrency ? value : value / 100;
  return numberFormat.format(value.toFixed(2));
};
function useLocalStorageReducer(key, reducer, initialState) {
  var dummyStorage = {
    getItem() {
      return null;
    },

    setItem() {},

    removeItem() {}

  };
  return dist_2(isClient ? window.localStorage : dummyStorage, key, reducer, initialState);
}
var getCheckoutData = {
  stripe(cart) {
    var _cart$allowedCountrie;

    var lineItems = [];

    for (var sku in cart.cartDetails) {
      lineItems.push({
        price: sku,
        quantity: cart.cartDetails[sku].quantity
      });
    }

    var options = {
      mode: 'payment',
      lineItems,
      successUrl: cart.successUrl,
      cancelUrl: cart.cancelUrl,
      billingAddressCollection: cart.billingAddressCollection ? 'required' : 'auto',
      submitType: 'auto'
    };

    if ((_cart$allowedCountrie = cart.allowedCountries) === null || _cart$allowedCountrie === void 0 ? void 0 : _cart$allowedCountrie.length) {
      options.shippingAddressCollection = {
        allowedCountries: cart.allowedCountries
      };
    }

    return options;
  }

};
function checkoutHandler(cart, checkoutOptions) {
  var serviceProperty = '';
  if (cart.stripe) serviceProperty = 'stripe';
  var needsCheckoutData = cart.mode === 'client-only';
  return /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (parameters) {
      if (!serviceProperty) {
        throw new Error('No compatible API has been defined, your options are: Stripe');
      }

      if (!checkoutOptions.modes.includes(cart.mode)) {
        throw new Error("Invalid checkout mode '".concat(cart.mode, "' was chosen. The valid modes are ").concat(new Intl.ListFormat().format(checkoutOptions.modes), "."));
      }

      var options = {
        sessionId: parameters === null || parameters === void 0 ? void 0 : parameters.sessionId
      };
      if (needsCheckoutData) options = getCheckoutData.stripe(cart);
      var {
        error
      } = yield checkoutOptions[serviceProperty](yield cart[serviceProperty], options, parameters);
      if (error) return error;
    });

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();
}

var cartInitialState = {
  lastClicked: '',
  shouldDisplayCart: false,
  stripe: null
};
function cartReducer(cart, action) {
  switch (action.type) {
    case 'store-last-clicked':
      return _objectSpread2(_objectSpread2({}, cart), {}, {
        lastClicked: action.sku
      });

    case 'cart-click':
      return _objectSpread2(_objectSpread2({}, cart), {}, {
        shouldDisplayCart: !cart.shouldDisplayCart
      });

    case 'cart-hover':
      return _objectSpread2(_objectSpread2({}, cart), {}, {
        shouldDisplayCart: true
      });

    case 'close-cart':
      return _objectSpread2(_objectSpread2({}, cart), {}, {
        shouldDisplayCart: false
      });

    case 'stripe-changed':
      return _objectSpread2(_objectSpread2({}, cart), {}, {
        stripe: action.stripe
      });

    default:
      return cart;
  }
}
var cartValuesInitialState = {
  cartDetails: {},
  totalPrice: 0,
  cartCount: 0
};

function Entry(productData, quantity, currency, language) {
  return _objectSpread2(_objectSpread2({}, productData), {}, {
    quantity,

    get value() {
      return this.price * this.quantity;
    },

    get formattedValue() {
      return formatCurrencyString({
        value: this.value,
        currency,
        language
      });
    }

  });
}

function cartValuesReducer(state, action) {
  function createEntry(product, count) {
    var entry = Entry(product, count, action.currency, action.language);
    return {
      cartDetails: _objectSpread2(_objectSpread2({}, state.cartDetails), {}, {
        [product.sku]: entry
      }),
      totalPrice: state.totalPrice + product.price * count,
      cartCount: state.cartCount + count
    };
  }

  function updateEntry(sku, count) {
    var cartDetails = _objectSpread2({}, state.cartDetails);

    var entry = cartDetails[sku];
    if (entry.quantity + count <= 0) return removeEntry(sku);
    cartDetails[sku] = Entry(entry, entry.quantity + count, action.currency, action.language);
    return {
      cartDetails,
      totalPrice: state.totalPrice + entry.price * count,
      cartCount: state.cartCount + count
    };
  }

  function removeEntry(sku) {
    var cartDetails = _objectSpread2({}, state.cartDetails);

    var totalPrice = state.totalPrice - cartDetails[sku].value;
    var cartCount = state.cartCount - cartDetails[sku].quantity;
    delete cartDetails[sku];
    return {
      cartDetails,
      totalPrice,
      cartCount
    };
  }

  function updateQuantity(sku, quantity) {
    var entry = state.cartDetails[sku];
    return updateEntry(sku, quantity - entry.quantity);
  }

  switch (action.type) {
    case 'add-item-to-cart':
      if (action.count <= 0) break;
      if (action.product.sku in state.cartDetails) return updateEntry(action.product.sku, action.count);
      return createEntry(action.product, action.count);

    case 'increment-item':
      if (action.count <= 0) break;
      if (action.sku in state.cartDetails) return updateEntry(action.sku, action.count);
      break;

    case 'decrement-item':
      if (action.count <= 0) break;
      if (action.sku in state.cartDetails) return updateEntry(action.sku, -action.count);
      break;

    case 'set-item-quantity':
      if (action.count < 0) break;
      if (action.sku in state.cartDetails) return updateQuantity(action.sku, action.quantity);
      break;

    case 'remove-item-from-cart':
      if (action.sku in state.cartDetails) return removeEntry(action.sku);
      break;

    case 'clear-cart':
      return cartValuesInitialState;

    default:
      return state;
  }

  console.warn('Invalid action arguments', action);
  return state;
}

var CartContext = createContext([_objectSpread2({
  lastClicked: '',
  shouldDisplayCart: false
}, cartValuesInitialState), () => {}]);
var CartProvider = (_ref) => {
  var {
    children,
    mode,
    stripe,
    successUrl,
    cancelUrl,
    currency,
    language = isClient ? navigator.language : 'en-US',
    billingAddressCollection = false,
    allowedCountries = null
  } = _ref;
  var [cart, cartDispatch] = useReducer(cartReducer, cartInitialState);
  useEffect(() => {
    cartDispatch({
      type: 'stripe-changed',
      stripe
    });
  }, [stripe]);
  var [cartValues, cartValuesDispatch] = useLocalStorageReducer('cart-values', cartValuesReducer, cartValuesInitialState); // combine dispatches and
  // memoize context value to avoid causing re-renders

  var contextValue = useMemo(() => [_objectSpread2(_objectSpread2(_objectSpread2({}, cart), cartValues), {}, {
    mode,
    successUrl,
    cancelUrl,
    currency,
    language,
    billingAddressCollection,
    allowedCountries
  }), action => {
    cartDispatch(action);
    cartValuesDispatch(_objectSpread2(_objectSpread2({}, action), {}, {
      currency,
      language
    }));
  }], [cart, cartDispatch, cartValues, cartValuesDispatch, mode, successUrl, cancelUrl, currency, language, billingAddressCollection, allowedCountries]);
  return /*#__PURE__*/react.createElement(CartContext.Provider, {
    value: contextValue
  }, children);
};
var useShoppingCart = () => {
  var [cart, dispatch] = useContext(CartContext);
  var {
    lastClicked,
    shouldDisplayCart,
    cartCount,
    cartDetails,
    totalPrice,
    currency,
    language
  } = cart;

  var addItem = function addItem(product) {
    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return dispatch({
      type: 'add-item-to-cart',
      product,
      count
    });
  };

  var removeItem = sku => dispatch({
    type: 'remove-item-from-cart',
    sku
  });

  var setItemQuantity = (sku, quantity) => dispatch({
    type: 'set-item-quantity',
    sku,
    quantity
  });

  var incrementItem = function incrementItem(sku) {
    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return dispatch({
      type: 'increment-item',
      sku,
      count
    });
  };

  var decrementItem = function decrementItem(sku) {
    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return dispatch({
      type: 'decrement-item',
      sku,
      count
    });
  };

  var clearCart = () => dispatch({
    type: 'clear-cart'
  });

  var storeLastClicked = sku => dispatch({
    type: 'store-last-clicked',
    sku
  });

  var handleCartClick = () => dispatch({
    type: 'cart-click'
  });

  var handleCartHover = () => dispatch({
    type: 'cart-hover'
  });

  var handleCloseCart = () => dispatch({
    type: 'close-cart'
  });

  var redirectToCheckout = checkoutHandler(cart, {
    modes: ['client-only', 'checkout-session'],

    stripe(stripe, options) {
      return stripe.redirectToCheckout(options);
    }

  });
  var checkoutSingleItem = checkoutHandler(cart, {
    modes: ['client-only'],

    stripe(stripe, options, _ref2) {
      var {
        sku,
        quantity = 1
      } = _ref2;
      options.lineItems = [{
        price: sku,
        quantity
      }];
      return stripe.redirectToCheckout(options);
    }

  });
  return {
    cartDetails,
    cartCount,
    totalPrice,

    get formattedTotalPrice() {
      return formatCurrencyString({
        value: totalPrice,
        currency,
        language
      });
    },

    addItem,
    removeItem,
    setItemQuantity,
    incrementItem,
    decrementItem,
    clearCart,
    lastClicked,
    storeLastClicked,
    shouldDisplayCart,
    handleCartClick,
    handleCartHover,
    handleCloseCart,
    redirectToCheckout,
    checkoutSingleItem
  };
};

export { CartContext, CartProvider, formatCurrencyString, isClient, useShoppingCart };
//# sourceMappingURL=index.es.js.map
